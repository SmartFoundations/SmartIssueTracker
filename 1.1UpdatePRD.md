# Smart! for Satisfactory 1.1 - Product Requirements Document

**Version**: 3.0  
**Date**: 2025-10-10  
**Product**: Smart! (SmartFoundations) Mod for Satisfactory  
**Target Platform**: Satisfactory 1.1+ (Unreal Engine 5.3.2)  
**SML Version**: 3.11.3+  
**Status**: Requirements Specification

---

## Executive Summary

### What
Smart! is a comprehensive building enhancement mod that provides precision placement, hologram manipulation, and automation tools for Satisfactory players. Originally built for Satisfactory Early Access (Update 7/8), it must be rebuilt for Satisfactory 1.1 (UE5) with modern architecture.

### Why
- **Engine Migration**: UE4 → UE5.3.2 requires complete rebuild
- **API Changes**: SML 3.4.x → SML 3.11.3 breaks existing patterns
- **Input System Overhaul**: Legacy input → Enhanced Input System
- **Architecture Debt**: Original monolithic design needs modernization
- **Native Feature Overlap**: Satisfactory 1.1 includes native Hold and Nudge

### Success Vision
Players can precisely manipulate building holograms (scaling, spacing, rotation) with visual feedback and automation tools, using a clean, maintainable codebase that integrates seamlessly with Satisfactory 1.1.

---

## Product Objectives

### Primary Objectives
1. **Restore Core Smart! Functionality**: Scaling, spacing, and visual guidance for Satisfactory 1.1
2. **Modernize Architecture**: Modular, maintainable codebase for future development
3. **Seamless Integration**: Zero conflicts with vanilla gameplay and other mods
4. **Professional UX**: Native-feeling UI integration and keybinding support
5. **Phased Release Strategy**: Ship tested features incrementally to users via Ficsit.app

### Non-Goals (Out of Scope)
- Replacing native Satisfactory features (Hold, Nudge)
- Creating standalone camera tools (extracted to separate mod)
- Supporting legacy Satisfactory versions (Update 7/8)
- Implementing belt straightening (using vanilla spline routing)
- Achieving 100% feature parity before initial release (phased release approach)

---

## Features Required

### Core Features (Must Have)

#### 1. Hologram Scaling
**User Story**: "As a player, I want to scale building holograms along X/Y/Z axes so I can adjust spacing between structures."

**Requirements**:
- Independent X/Y/Z axis offset control
- Visual arrows showing active axes (Red=X, Green=Y, Blue=Z)
- Configurable step size (default: 50cm per increment)
- Reset functionality to return to default size
- Real-time visual feedback during scaling
- Grid snapping for precise placement
- Collision validation after scaling
- Support for foundations, walls, walkways, pillars

**Success Criteria**:
- Player can offset foundations by 0.5m increments per axis
- Arrows display correctly and update in real-time
- Scaled holograms remain valid (no clipping)
- Works in multiplayer (state syncs to all clients)

---

#### 2. Spacing Automation
**User Story**: "As a player, I want automatic gaps between consecutive placements so I can build evenly-spaced structures quickly."

**Requirements**:
- Toggle spacing mode on/off
- Three spacing modes: X-only, X+Y, X+Y+Z
- Fixed 0.5m step per axis
- Automatic gap calculation between placements
- Visual indicator of current mode
- Persists across build sessions

**Success Criteria**:
- Consecutive foundation placements auto-space by 0.5m
- Mode cycles: Off → X → X+Y → X+Y+Z → Off
- Spacing respects hologram validation
- Works with scaling simultaneously

---

#### 3. Steps (Vertical Layer Control)
**User Story**: "As a player, I want to move up/down by building height increments so I can stack structures without moving my character."

**Requirements**:
- Move hologram up/down by building-specific height
- Automatic height calculation per building type
- Independent of character jetpack
- Floor validation to prevent floating structures
- Support for walls, frames, multi-level factories

**Success Criteria**:
- Player can stack 3 wall segments vertically without jetpack
- Height steps match building dimensions exactly
- Invalid placements (no support) prevented
- Works on uneven terrain

---

#### 4. Stagger (Grid Offset)
**User Story**: "As a player, I want to offset child holograms laterally in grid placement so I can create checkerboard and alternating patterns."

**Requirements**:
- Hold modifier key + scroll to adjust lateral offset
- Incremental offset steps (0.5m / 50cm per tick)
- Applies to child holograms in grid/array placement
- Affects Y-axis offset in child positioning (e.g., `OffsetY = baseOffset + StaggerCounter * childIndex`)
- Independent of character position
- Visual feedback showing offset amount

**Success Criteria**:
- Player can create checkerboard foundation patterns
- Offset increments are consistent (0.5m steps)
- Works with all grid-placed buildings
- Offset resets between build sessions

**Note**: Original Smart called this "Twirl" but it's being renamed to "Stagger" to better reflect its purpose (lateral offset, not rotation). True rotation control is a separate future feature.

---

#### 5. ~~Levitation (Vertical Offset)~~ - REMOVED
**Status**: **OUT OF SCOPE** - Satisfactory 1.0+ includes native vertical nudging

**Critical Distinction**:
- **Steps (Feature #3 above)**: Building-specific layer stacking - **IN SCOPE**
  - Moves hologram by building height increments (e.g., wall height)
  - Used for stacking structures vertically
  - Different from arbitrary vertical offset
- **Levitation (this feature)**: Arbitrary vertical offset - **OUT OF SCOPE**
  - Original Smart! feature for fine-grained vertical positioning
  - Now covered by native PageUp/PageDown (vertical nudge)

**Native Implementation**: 
- PageUp/PageDown keys provide arbitrary vertical offset
- Part of base game's nudge system
- No Smart implementation needed

**Original Smart Levitation**:
- Allowed vertical offset independent of character (L key + scroll)
- 50cm step increments, arbitrary offset amount
- Replaced by native functionality in Satisfactory 1.0+
- Feature intentionally excluded from Smart 1.1 rebuild

**Note**: Don't confuse Steps (layer stacking) with Levitation (arbitrary offset). Steps is still needed and in scope!

---

#### 6. Visual Arrow System
**User Story**: "As a player, I want colored arrows showing hologram orientation so I understand which direction adjustments will apply."

**Requirements**:
- Three colored arrows: X=Red, Y=Green, Z=Blue
- Dynamic positioning based on hologram bounds
- Toggle visibility on/off
- Configurable vertical offset
- Arrows update during scaling/rotation
- Support for all building types

**Success Criteria**:
- Arrows visible when toggled on
- Correct positioning for foundations, walls, factories
- Performance: <0.1ms render overhead
- Arrows don't obscure hologram

---

#### 7. Enhanced Input Integration
**User Story**: "As a player, I want to rebind Smart! keys in the game's Options menu like any other control."

**Requirements**:
- Use Enhanced Input with `UFGInputMappingContext`
- Parent context: `MC_PlayerActions` (activates in build mode)
- All actions appear in Options → Controls → Mods
- User-remappable keys
- Default keybinds avoid conflicts with vanilla
- Context-aware (only active when build gun equipped)

**Success Criteria**:
- Smart! keybinds visible in game settings
- Player can remap all keys
- Zero conflicts with vanilla controls
- Actions fire only in appropriate contexts
- Multiplayer compatible

---

#### 8. Configuration System
**User Story**: "As a player, I want to customize Smart! behavior and save my preferences."

**Requirements**:
- Use SML ModConfiguration system (Blueprint-based)
- Settings appear in game's Mods menu
- Automatic UI generation from schema
- Configurable options:
  - Arrow visibility and offset
  - Scaling step size
  - Spacing mode defaults
  - Auto-hold behavior
  - Nudge step size
- Settings persist across sessions
- Per-player settings in multiplayer

**Success Criteria**:
- Settings accessible via Mods menu
- Changes save automatically
- UI generated from config schema
- No custom widget maintenance needed
- Settings sync in multiplayer

---

### Advanced Features (Should Have)

#### 9. Extend (Rapid Line Placement)
**User Story**: "As a player, I want to automatically continue placing structures in a direction so I can build long conveyor/foundation runs quickly."

**Requirements**:
- Hotkey activation
- Automatic placement in aimed direction
- Works with spacing mode
- Collision validation per segment
- Cancel on invalid placement
- Support for foundations, conveyors, pipes

**Success Criteria**:
- Player can place 10 foundations in a row with one keypress per placement
- Direction follows aim point
- Stops on collision/invalid placement
- Works with scaled/spaced holograms

---

#### 10. Auto-Connect (Future)
**User Story**: "As a player, I want belts/pipes to automatically connect when I place splitters/mergers nearby."

**Requirements**:
- Automatic belt connection: splitters/mergers to buildings
- Automatic pipe connection: junctions to buildings
- Configurable modes: Always / Once / Never
- Throughput validation (belt tier appropriate)
- Uses vanilla spline routing (NO belt straightening)
- Connection validation before placement
- Settings UI for granular control

**Success Criteria**:
- Splitter near building → auto-connects belt
- Pipe junction → auto-connects pipes
- Connections use appropriate tier (Mk.1-5)
- Vanilla spline routing (natural curves)
- Performance: <0.5ms per placement check

---

### Building Type Support

**Universal Support via Adapter Pattern** (Must Have):
All reasonable building types supported through adapter system that handles type-specific behavior:

**Structural Buildings**:
- Foundations (all sizes, types)
- Walls (standard, angled, corners)
- Walkways (standard, ramps, stairs)
- Pillars (all types)
- Ramps, ladders, catwalks

**Factory Buildings**:
- Manufacturers (all sizes)
- Smelters, Constructors, Assemblers
- Refineries, Blenders, Packagers
- Foundries, Hadron Colliders
- Storage containers
- Power generators

**Transportation**:
- Conveyor belts
- Conveyor lifts
- Conveyor splitters/mergers
- Pipelines
- Pipeline junctions
- Support poles
- Train stations, platforms

**Special Buildings**:
- Conveyor floor holes (passthrough adapters)
- Lookout towers
- Ladders
- Hypertube entrances

**Adapter Architecture**:
- Adapters handle building-specific nuances (size calculation, snapping, validation)
- No per-building conditional logic in core features
- Extensible pattern for future building types
- Foundation adapter, Factory adapter, Passthrough adapter, etc.
- Generic fallback adapter for unsupported types

---

## Scope Definition

### In Scope (This Product)
- ✅ Hologram scaling (X/Y/Z axes)
- ✅ Spacing automation (gap management)
- ✅ Steps (vertical layer control)
- ✅ Stagger (grid offset for checkerboard patterns)
- ✅ Visual arrows (orientation feedback)
- ✅ Enhanced Input integration
- ✅ SML Configuration system
- ✅ Extend (rapid placement)
- ✅ Auto-Connect (future - vanilla routing)
- ✅ Adapter system for building-type-specific behavior
- ✅ Modular, maintainable architecture
- ✅ Universal building type support (all reasonable buildables)
- ✅ Single-player functionality (MVP)
- ✅ Phased release process with version branches

### Out of Scope (Explicitly NOT Building)
- ❌ **Hold Feature**: Native in Satisfactory 1.1 (H key)
- ❌ **Nudge Feature (Implementation)**: Native in Satisfactory 1.1 (Arrow keys + PageUp/PageDown)
  - ⚠️ **Compatibility Required**: Smart! MUST coordinate with native nudge to prevent conflicts
  - Need to detect native nudge state and ensure Smart! features don't interfere
- ❌ **Levitation Feature**: Native vertical nudging (PageUp/PageDown) covers this
- ❌ **Camera Tools**: Extracted to separate mod (CameraPiP)
- ❌ **Belt Straightening**: Using vanilla spline routing instead
- ❌ **Legacy Version Support**: No Update 7/8 compatibility
- ❌ **Custom Snap Logic**: Use native 1.1 snapping if sufficient
- ❌ **Restore Feature**: Unclear use case, pending research
- ❌ **True Rotation Control**: Future feature (not part of v1.0)

### Deferred (Future Consideration)
- **Multiplayer Support**: Client-server sync, RCO implementation (post-MVP)
- **Rotation Control**: Fine-grained rotation (5° increments)
- Advanced scaling (non-uniform, proportional modes)
- Spline manipulation (belt/pipe curves)
- Recipe copying between buildings
- Build templates/blueprints
- Statistics tracking

---

## Success Metrics

### User Experience
- **Time to First Success**: Player can scale foundation within 5 minutes of install
- **Keybind Clarity**: 90% of users can find rebind settings without help
- **Feature Discovery**: Visual arrows provide immediate feedback
- **Error Recovery**: Invalid placements prevented with clear visual feedback

### Technical Performance
- **Input Latency**: <1ms from keypress to handler execution
- **Frame Impact**: <0.1ms tick overhead when active
- **UI Responsiveness**: Settings menu opens in <100ms
- **Multiplayer Sync**: State replication <100ms across clients

### Quality Metrics
- **Compatibility**: Zero conflicts with vanilla keybinds
- **Stability**: No crashes in 100 hours of gameplay testing
- **Multiplayer**: Works reliably with 4+ players
- **Build Health**: Zero compiler warnings, all tests passing

### Adoption Metrics (Post-Release)
- **Satisfactory Mod Repository Downloads**: Track via SMR stats
- **User Feedback**: Monitor Discord/Reddit for issues
- **Bug Reports**: <5% critical bugs in first month
- **Feature Requests**: Track most-wanted enhancements

---

## Technical Requirements

### Platform Requirements
- **Game Version**: Satisfactory 1.1+ (minimum: 1.1.0)
- **Engine**: Unreal Engine 5.3.2
- **Mod Framework**: SML 3.11.3+ (minimum: 3.11.0)
- **Build Tool**: Alpakit (SML mod packager)
- **Development**: Visual Studio 2022, C++20

### Performance Requirements
- **Input Response**: <1ms latency (keypress → handler)
- **Tick Overhead**: <0.1ms per frame when hologram active
- **Memory Footprint**: <50MB additional RAM usage
- **Load Time**: <2s mod initialization on game startup
- **UI Rendering**: Settings menu <16ms frame time (60 FPS)

### Compatibility Requirements
- **Keybinds**: Zero conflicts with vanilla controls (use unique keys)
- **Mod Ecosystem**: Compatible with other building mods (no shared state)
- **Save Games**: No save file corruption (persistent state optional)
- **Multiplayer**: Designed for future client-server support (not required for MVP)
- **Game Updates**: Graceful degradation if APIs change

### Architecture Requirements
- **Modularity**: Single Responsibility Principle for classes
- **Testability**: Unit tests for business logic (>80% coverage goal)
- **Maintainability**: Clear separation: Input → Subsystem → Features
- **Extensibility**: Adapter pattern for new building types
- **Documentation**: Comprehensive documentation per standards (see Documentation Requirements)
- **Release Management**: Version branches for released builds, separate development branches

---

## Technical Constraints

### Satisfactory-Specific Constraints
1. **Input System**:
   - MUST use `UFGInputMappingContext` (not standard UE5 `InputMappingContext`)
   - MUST parent to `MC_PlayerActions` for build mode activation
   - MUST enable "Player Mappable" on all actions
   - Display names appear in Options → Controls → Mods

2. **Hologram System**:
   - MUST respect `AFGBuildGun` state machine
   - MUST validate via `AFGHologram::IsValid()`
   - MUST handle client prediction + server authority
   - MUST integrate with build mode UI

3. **Networking**:
   - MUST use RCO (Remote Call Object) for client→server
   - MUST validate authority before applying changes
   - MUST handle latency gracefully (client prediction)
   - MUST replicate state to all clients

4. **Build Gun Integration**:
   - MUST detect hologram activation/deactivation
   - MUST clean up state when build mode exits
   - MUST not interfere with vanilla building
   - MUST preserve vanilla hotbar/recipe switching

### SML Requirements
- Declare SML dependency: `^3.11.3` in plugin descriptor
- Use SML ModConfiguration system (no custom config files)
- Register RCO with SML networking
- Follow SML naming conventions (SF prefix)
- Content in `/SmartFoundations/` plugin directory

### Design Constraints
- **No Belt Straightening**: Use vanilla spline routing (simpler, more compatible)
- **No Base Game Modifications**: All features via hooks/adapters
- **Numpad-Exclusive Keybinds**: Default to avoid conflicts (user can remap)
- **Minimal Tick Overhead**: Optimize hot paths (<0.1ms)
- **Native Feature Compatibility**: Smart! MUST coordinate with native Nudge/Hold to prevent conflicts
  - Detect when native features are active
  - Ensure Smart! state management doesn't interfere
  - Handle input priority correctly
  - Document integration patterns

---

## Dependencies

### External Dependencies
- **Satisfactory 1.1+**: Core game APIs (AFGBuildGun, AFGHologram, etc.)
- **SML 3.11.3+**: Mod framework (RCO, config, hooks)
- **Enhanced Input**: UE5 input system (UFGInputMappingContext)
- **UMG**: UI widgets for potential custom displays
- **Networking**: UE5 replication for multiplayer

### Internal Dependencies
- **Enhanced Input Operational**: All features depend on working input
- **RCO Functional**: Multiplayer requires working RCO
- **Subsystem Architecture**: Features depend on modular subsystem
- **Hologram Adapters**: Type-specific features need adapter pattern

### Assumptions
- **Internet Connectivity**: Not required (local/LAN play supported)
- **Player Skill**: Familiar with Satisfactory building basics
- **Hardware**: Standard gaming PC (60 FPS target)
- **Mod Installation**: Players use SMM (Satisfactory Mod Manager)

---

## Release Strategy

### MVP (Minimum Viable Product)
**Initial Release Scope**:
- Single-player functionality only
- Core features: Scaling, Spacing, Steps, Stagger, Arrows
- Enhanced Input integration
- Configuration system
- Foundation + Wall + Walkway adapters

**Multiplayer (Post-MVP)**:
- Client-server state synchronization
- RCO (Remote Call Object) implementation
- Authority validation
- Latency handling
- Will be implemented after MVP is stable

### Phased Release Process

**Development → Testing → Release Cycle**:
1. **Feature Development** (Development Branch)
   - Implement feature in `dev` or feature-specific branch
   - Code review and testing
   - Documentation updated

2. **Internal Testing** (Testing Branch)
   - Merge to `testing` branch
   - Deploy to dedicated testers
   - Iterate on feedback
   - Bug fixing

3. **Release Preparation** (Release Branch)
   - Create version branch (e.g., `release/v0.1.0`)
   - Final testing
   - Package with Alpakit
   - Update changelog

4. **Ficsit.app Deployment**
   - Upload tested build to Satisfactory Mod Repository
   - Tag release in git (e.g., `v0.1.0`)
   - Monitor user feedback

5. **Hotfix Support** (Version Branch)
   - Critical bugs fixed in version branch
   - Hotfix releases (e.g., `v0.1.1`)
   - Fixes backported to development branch

**Branch Strategy**:
```
master (stable releases)
├── release/v0.1.x (hotfixes for v0.1)
├── release/v0.2.x (hotfixes for v0.2)
└── dev (active development)
    ├── feature/multiplayer
    ├── feature/auto-connect
    └── feature/rotation-control
```

**Version Numbering**:
- **Major.Minor.Patch** (Semantic Versioning)
- Example: `v0.1.0` → `v0.1.1` (hotfix) → `v0.2.0` (new features)
- Pre-release builds: `v0.1.0-alpha.1`, `v0.1.0-beta.2`

---

## Documentation Requirements

### Purpose
Establish clear documentation standards to prevent documentation sprawl, redundancy, and inconsistency. All documentation must have a clear purpose, location, and maintenance policy.

### Documentation Types & Structure

**1. Product Documentation** (`.taskmaster/docs/`)
- **PRD** (`prd.txt`) - Product requirements (this document)
- **Development Plan** (`development_plan.md`) - Detailed implementation guide
- **Changelog** (`CHANGELOG.md`) - Version history and changes

**2. Architecture Documentation** (`docs/Architecture/`)
- **One document per architectural decision**
- **Naming**: `{Component}_Analysis.md` or `{Component}_Design.md`
- **Examples**: `Phase0_Refactoring_Plan.md`, `Configuration_System_Analysis.md`
- **Purpose**: High-level design decisions, system architecture, migration plans

**3. Feature Documentation** (`docs/Features/{FeatureName}/`)
- **One directory per feature** (Scaling, Spacing, Steps, etc.)
- **Required files per feature**:
  - `README.md` - User-facing: how to use the feature
  - `TECHNICAL.md` - Developer-facing: implementation details
- **Naming convention**: `{FeatureName}/` (PascalCase)
- **Examples**: `docs/Features/Scaling/`, `docs/Features/Spacing/`

**4. API Documentation** (`docs/API/` + inline)
- **Module summaries**: `docs/{ModuleName}/API.md`
- **Class documentation**: Doxygen comments in source files
- **Generated docs**: `docs/doxygen/html/` (auto-generated, not committed)

**5. Code Documentation** (Inline in source files)
- **Doxygen format** for all public APIs
- **Class-level**: Purpose, responsibilities, usage examples
- **Function-level**: Parameters, return values, side effects
- **Complex logic**: Inline comments explaining "why", not "what"

### Documentation Standards

#### File Naming Conventions
```
✅ CORRECT:
- docs/Features/Scaling/README.md
- docs/Architecture/Phase0_Refactoring_Plan.md
- docs/SmartFoundations/API.md

❌ INCORRECT:
- docs/scaling_feature.md (wrong location)
- docs/Features/Scaling/scaling-tech-doc.md (non-standard name)
- docs/ScalingReadme.md (wrong location + case)
```

#### Document Structure Requirements

**All documentation must include**:
1. **Title** (H1 heading)
2. **Purpose/Summary** (1-2 sentences)
3. **Last Updated Date** (YYYY-MM-DD)
4. **Related Documents** (links to related docs)

**Feature Documentation Structure**:
```markdown
# Feature Name

**Last Updated**: 2025-10-10
**Related**: [TECHNICAL.md](./TECHNICAL.md), [PRD](../../.taskmaster/docs/prd.txt)

## Summary
[One paragraph: what the feature does]

## User Guide
[How to use the feature]

## Configuration
[Settings and options]

## Known Issues
[Current limitations]
```

**Technical Documentation Structure**:
```markdown
# TECHNICAL: Feature Name

**Last Updated**: 2025-10-10
**Related**: [README.md](./README.md), [Source Code](../../Source/...)

## Implementation Overview
[High-level architecture]

## Key Components
[Classes, functions, data structures]

## Code Flow
[Sequence diagrams, flowcharts]

## Testing
[Test strategy and coverage]
```

#### Anti-Patterns (DO NOT DO)

❌ **Multiple documents for same topic**:
- Don't create `Scaling_v1.md`, `Scaling_v2.md`, `Scaling_Final.md`
- Update existing document or use git history

❌ **Unclear document purpose**:
- Don't create `notes.md`, `thoughts.md`, `draft.md`
- Every document must have clear purpose and audience

❌ **Orphaned documentation**:
- Don't create docs without linking from parent docs
- Update architecture index when adding new docs

❌ **Duplicate information**:
- Don't copy-paste between docs
- Link to authoritative source instead

❌ **Stale documentation**:
- Don't leave outdated docs without deprecation notice
- Update "Last Updated" date when modifying

### Documentation Workflow

**When to Create New Documentation**:
1. **New Feature**: Create `docs/Features/{FeatureName}/` with README + TECHNICAL
2. **Architectural Decision**: Create `docs/Architecture/{Decision}_Analysis.md`
3. **New Module**: Update `docs/{ModuleName}/API.md`
4. **Major Refactor**: Create migration/design doc in `docs/Architecture/`

**When to Update Existing Documentation**:
1. **Feature Changes**: Update feature's TECHNICAL.md
2. **API Changes**: Update inline Doxygen + regenerate docs
3. **Bug Fixes**: Update feature's "Known Issues" section
4. **Architecture Changes**: Update relevant Architecture doc

**Documentation Review Process**:
1. **Every PR must include documentation updates**
2. **Check for broken links** before merging
3. **Verify "Last Updated" dates** are current
4. **Ensure cross-references are accurate**

### Tools & Automation

**Doxygen**:
- Configuration: `Doxyfile` in repo root
- Generate: `doxygen Doxyfile`
- Output: `docs/doxygen/html/` (gitignored)
- Regenerate before releases

**Link Checking**:
- Validate all markdown links before release
- Use tools like `markdown-link-check`

**Documentation Index**:
- Maintain `docs/README.md` as master index
- Auto-update when adding new docs

### Success Criteria

**Well-Documented Codebase**:
- ✅ Every feature has README + TECHNICAL docs
- ✅ All public APIs have Doxygen comments
- ✅ Architecture decisions are documented
- ✅ No duplicate or contradictory documentation
- ✅ New developers can find information in <5 minutes
- ✅ Documentation is accurate and up-to-date

---

## Risks & Mitigation

### Technical Risks
1. **API Instability**: Satisfactory 1.1 APIs may change
   - **Mitigation**: Use adapter pattern, test each game patch
   
2. **Multiplayer Sync**: State desync in high-latency scenarios
   - **Mitigation**: Server authority, client prediction, extensive testing

3. **Performance**: Tick overhead with many holograms
   - **Mitigation**: Profile early, optimize hot paths, lazy updates

### Scope Risks
1. **Feature Creep**: Community requests for additional features
   - **Mitigation**: Strict PRD adherence, defer non-essential features

2. **Compatibility**: Conflicts with other building mods
   - **Mitigation**: Coordinate with mod community, use unique state

### Quality Risks
1. **Regression Bugs**: New features break existing functionality
   - **Mitigation**: Comprehensive test suite, phased rollout

2. **User Confusion**: Complex feature set overwhelming
   - **Mitigation**: Clear visual feedback, in-game hints, documentation

---

## Appendices

### A. Terminology
- **AFG**: "A Factory Game" - Coffee Stain Studios naming prefix
- **Hologram**: Preview of buildable before placement
- **RCO**: Remote Call Object - SML networking pattern
- **SML**: Satisfactory Mod Loader
- **Alpakit**: SML mod packaging tool
- **Enhanced Input**: UE5's input system (replaces legacy input)
- **MC**: Mapping Context (Enhanced Input)
- **Adapter**: Pattern for hologram-agnostic feature implementation
- **UE Units**: Unreal Engine distance units; 1 UE unit = 1 cm (e.g., 50 UE units = 50cm = 0.5m)

### B. References
- **Satisfactory Modding Docs**: https://docs.ficsit.app/
- **SML GitHub**: https://github.com/satisfactorymodding/SatisfactoryModLoader
- **UE5 Enhanced Input**: https://docs.unrealengine.com/5.3/en-US/enhanced-input-in-unreal-engine/
- **Original Smart! (SMR)**: https://ficsit.app/mod/SmartFoundations

### C. Related Documentation
- **Phase 0 Refactoring Plan**: `docs/Architecture/Phase0_Refactoring_Plan.md`
- **Configuration System Analysis**: `docs/Architecture/Configuration_System_Analysis.md`
- **Belt Straightening Analysis**: `docs/Architecture/Belt_Straightening_Analysis.md` (design decision: NOT implementing)
- **Future Features Analysis**: `docs/Architecture/Future_Features_Analysis.md`
- **Development Plan**: `docs/Development_Plan.md` (detailed implementation guide)

---

**End of Product Requirements Document**

This document defines WHAT Smart! must deliver for Satisfactory 1.1. For project tracking, execution status, and detailed implementation plans, see Taskmaster tasks and development documentation.
